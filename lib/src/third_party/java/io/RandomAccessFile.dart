// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "File.dart" as file_;

/// from: java.io.RandomAccessFile
class RandomAccessFile extends jni.JObject {
  @override
  late final jni.JObjType<RandomAccessFile> $type = type;

  RandomAccessFile.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"java/io/RandomAccessFile");

  /// The type which includes information such as the signature of this class.
  static const type = $RandomAccessFileType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile(
    jni.JString string,
    jni.JString string1,
  ) {
    return RandomAccessFile.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [string.reference, string1.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Ljava/io/File;Ljava/lang/String;)V");

  /// from: public void <init>(java.io.File file, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile.new1(
    file_.File file,
    jni.JString string,
  ) {
    return RandomAccessFile.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [file.reference, string.reference]).object);
  }

  static final _id_getFD = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFD", r"()Ljava/io/FileDescriptor;");

  /// from: public final java.io.FileDescriptor getFD()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getFD() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFD, jni.JniCallType.objectType, []).object);
  }

  static final _id_getChannel = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getChannel", r"()Ljava/nio/channels/FileChannel;");

  /// from: public final java.nio.channels.FileChannel getChannel()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getChannel, jni.JniCallType.objectType, []).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"()I");

  /// from: public int read()
  int read() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read, jni.JniCallType.intType, []).integer;
  }

  static final _id_read1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([BII)I");

  /// from: public int read(byte[] bs, int i, int i1)
  int read1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read1,
        jni.JniCallType.intType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_read2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([B)I");

  /// from: public int read(byte[] bs)
  int read2(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read2, jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_readFully =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFully", r"([B)V");

  /// from: public final void readFully(byte[] bs)
  void readFully(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_readFully1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readFully", r"([BII)V");

  /// from: public final void readFully(byte[] bs, int i, int i1)
  void readFully1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readFully1,
        jni.JniCallType.voidType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_skipBytes =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"skipBytes", r"(I)I");

  /// from: public int skipBytes(int i)
  int skipBytes(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_skipBytes,
        jni.JniCallType.intType, [jni.JValueInt(i)]).integer;
  }

  static final _id_write =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"write", r"(I)V");

  /// from: public void write(int i)
  void write(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_write1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"write", r"([B)V");

  /// from: public void write(byte[] bs)
  void write1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write1,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_write2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"write", r"([BII)V");

  /// from: public void write(byte[] bs, int i, int i1)
  void write2(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write2,
        jni.JniCallType.voidType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_getFilePointer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFilePointer", r"()J");

  /// from: public long getFilePointer()
  int getFilePointer() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFilePointer, jni.JniCallType.longType, []).long;
  }

  static final _id_seek =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"seek", r"(J)V");

  /// from: public void seek(long j)
  void seek(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_seek, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_length =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"length", r"()J");

  /// from: public long length()
  int length() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_length, jni.JniCallType.longType, []).long;
  }

  static final _id_setLength =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setLength", r"(J)V");

  /// from: public void setLength(long j)
  void setLength(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setLength, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_readBoolean =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readBoolean", r"()Z");

  /// from: public final boolean readBoolean()
  bool readBoolean() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readBoolean, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_readByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readByte", r"()B");

  /// from: public final byte readByte()
  int readByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByte, jni.JniCallType.byteType, []).byte;
  }

  static final _id_readUnsignedByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUnsignedByte", r"()I");

  /// from: public final int readUnsignedByte()
  int readUnsignedByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUnsignedByte, jni.JniCallType.intType, []).integer;
  }

  static final _id_readShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShort", r"()S");

  /// from: public final short readShort()
  int readShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShort, jni.JniCallType.shortType, []).short;
  }

  static final _id_readUnsignedShort = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUnsignedShort", r"()I");

  /// from: public final int readUnsignedShort()
  int readUnsignedShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUnsignedShort, jni.JniCallType.intType, []).integer;
  }

  static final _id_readChar =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readChar", r"()C");

  /// from: public final char readChar()
  int readChar() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readChar, jni.JniCallType.charType, []).char;
  }

  static final _id_readInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readInt", r"()I");

  /// from: public final int readInt()
  int readInt() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readInt, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLong", r"()J");

  /// from: public final long readLong()
  int readLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readFloat =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFloat", r"()F");

  /// from: public final float readFloat()
  double readFloat() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readFloat, jni.JniCallType.floatType, []).float;
  }

  static final _id_readDouble =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readDouble", r"()D");

  /// from: public final double readDouble()
  double readDouble() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readDouble, jni.JniCallType.doubleType, []).doubleFloat;
  }

  static final _id_readLine = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readLine", r"()Ljava/lang/String;");

  /// from: public final java.lang.String readLine()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readLine() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLine, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUTF = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUTF", r"()Ljava/lang/String;");

  /// from: public final java.lang.String readUTF()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUTF() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUTF, jni.JniCallType.objectType, []).object);
  }

  static final _id_writeBoolean = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeBoolean", r"(Z)V");

  /// from: public final void writeBoolean(boolean z)
  void writeBoolean(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeBoolean,
        jni.JniCallType.voidType, [z ? 1 : 0]).check();
  }

  static final _id_writeByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeByte", r"(I)V");

  /// from: public final void writeByte(int i)
  void writeByte(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeByte,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_writeShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeShort", r"(I)V");

  /// from: public final void writeShort(int i)
  void writeShort(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeShort,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_writeChar =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeChar", r"(I)V");

  /// from: public final void writeChar(int i)
  void writeChar(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeChar,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_writeInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeInt", r"(I)V");

  /// from: public final void writeInt(int i)
  void writeInt(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeInt,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_writeLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeLong", r"(J)V");

  /// from: public final void writeLong(long j)
  void writeLong(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeLong, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_writeFloat =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"writeFloat", r"(F)V");

  /// from: public final void writeFloat(float f)
  void writeFloat(
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeFloat,
        jni.JniCallType.voidType, [jni.JValueFloat(f)]).check();
  }

  static final _id_writeDouble = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeDouble", r"(D)V");

  /// from: public final void writeDouble(double d)
  void writeDouble(
    double d,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeDouble, jni.JniCallType.voidType, [d]).check();
  }

  static final _id_writeBytes = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeBytes", r"(Ljava/lang/String;)V");

  /// from: public final void writeBytes(java.lang.String string)
  void writeBytes(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeBytes,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_writeChars = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeChars", r"(Ljava/lang/String;)V");

  /// from: public final void writeChars(java.lang.String string)
  void writeChars(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeChars,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_writeUTF = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeUTF", r"(Ljava/lang/String;)V");

  /// from: public final void writeUTF(java.lang.String string)
  void writeUTF(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeUTF,
        jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_finalize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"finalize", r"()V");

  /// from: protected void finalize()
  void finalize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_finalize, jni.JniCallType.voidType, []).check();
  }
}

class $RandomAccessFileType extends jni.JObjType<RandomAccessFile> {
  const $RandomAccessFileType();

  @override
  String get signature => r"Ljava/io/RandomAccessFile;";

  @override
  RandomAccessFile fromRef(jni.JObjectPtr ref) => RandomAccessFile.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RandomAccessFileType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RandomAccessFileType) &&
        other is $RandomAccessFileType;
  }
}
