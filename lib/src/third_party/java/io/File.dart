// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: java.io.File
class File extends jni.JObject {
  @override
  late final jni.JObjType<File> $type = type;

  File.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"java/io/File");

  /// The type which includes information such as the signature of this class.
  static const type = $FileType();
  static final _id_pathSeparator = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"pathSeparator",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String pathSeparator
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get pathSeparator =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_pathSeparator, jni.JniCallType.objectType)
          .object);

  static final _id_pathSeparatorChar = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"pathSeparatorChar",
    r"C",
  );

  /// from: static public final char pathSeparatorChar
  static int get pathSeparatorChar => jni.Jni.accessors
      .getStaticField(
          _class.reference, _id_pathSeparatorChar, jni.JniCallType.charType)
      .char;

  static final _id_separator = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"separator",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String separator
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get separator =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_separator, jni.JniCallType.objectType)
          .object);

  static final _id_separatorChar = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"separatorChar",
    r"C",
  );

  /// from: static public final char separatorChar
  static int get separatorChar => jni.Jni.accessors
      .getStaticField(
          _class.reference, _id_separatorChar, jni.JniCallType.charType)
      .char;

  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory File(
    jni.JString string,
  ) {
    return File.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [string.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new1(
    jni.JString string,
    jni.JString string1,
  ) {
    return File.fromRef(jni.Jni.accessors.newObjectWithArgs(_class.reference,
        _id_new1, [string.reference, string1.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Ljava/io/File;Ljava/lang/String;)V");

  /// from: public void <init>(java.io.File file, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new2(
    File file,
    jni.JString string,
  ) {
    return File.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new2, [file.reference, string.reference]).object);
  }

  static final _id_new3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Ljava/net/URI;)V");

  /// from: public void <init>(java.net.URI uRI)
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new3(
    jni.JObject uRI,
  ) {
    return File.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new3, [uRI.reference]).object);
  }

  static final _id_getName = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getName, jni.JniCallType.objectType, []).object);
  }

  static final _id_getParent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getParent", r"()Ljava/lang/String;");

  /// from: public java.lang.String getParent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getParent() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getParent, jni.JniCallType.objectType, []).object);
  }

  static final _id_getParentFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getParentFile", r"()Ljava/io/File;");

  /// from: public java.io.File getParentFile()
  /// The returned object must be released after use, by calling the [release] method.
  File getParentFile() {
    return const $FileType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getParentFile, jni.JniCallType.objectType, []).object);
  }

  static final _id_getPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getPath", r"()Ljava/lang/String;");

  /// from: public java.lang.String getPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPath() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPath, jni.JniCallType.objectType, []).object);
  }

  static final _id_isAbsolute =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isAbsolute", r"()Z");

  /// from: public boolean isAbsolute()
  bool isAbsolute() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isAbsolute, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getAbsolutePath = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getAbsolutePath", r"()Ljava/lang/String;");

  /// from: public java.lang.String getAbsolutePath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAbsolutePath() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAbsolutePath, jni.JniCallType.objectType, []).object);
  }

  static final _id_getAbsoluteFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getAbsoluteFile", r"()Ljava/io/File;");

  /// from: public java.io.File getAbsoluteFile()
  /// The returned object must be released after use, by calling the [release] method.
  File getAbsoluteFile() {
    return const $FileType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAbsoluteFile, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCanonicalPath = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCanonicalPath", r"()Ljava/lang/String;");

  /// from: public java.lang.String getCanonicalPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getCanonicalPath() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getCanonicalPath,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getCanonicalFile = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCanonicalFile", r"()Ljava/io/File;");

  /// from: public java.io.File getCanonicalFile()
  /// The returned object must be released after use, by calling the [release] method.
  File getCanonicalFile() {
    return const $FileType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getCanonicalFile,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_toURL = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toURL", r"()Ljava/net/URL;");

  /// from: public java.net.URL toURL()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toURL() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toURL, jni.JniCallType.objectType, []).object);
  }

  static final _id_toURI = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toURI", r"()Ljava/net/URI;");

  /// from: public java.net.URI toURI()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toURI() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toURI, jni.JniCallType.objectType, []).object);
  }

  static final _id_canRead =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canRead", r"()Z");

  /// from: public boolean canRead()
  bool canRead() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canRead, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_canWrite =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canWrite", r"()Z");

  /// from: public boolean canWrite()
  bool canWrite() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canWrite, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_exists =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exists", r"()Z");

  /// from: public boolean exists()
  bool exists() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exists, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isDirectory =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDirectory", r"()Z");

  /// from: public boolean isDirectory()
  bool isDirectory() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirectory, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isFile =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isFile", r"()Z");

  /// from: public boolean isFile()
  bool isFile() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isFile, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isHidden =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHidden", r"()Z");

  /// from: public boolean isHidden()
  bool isHidden() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHidden, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_lastModified = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastModified", r"()J");

  /// from: public long lastModified()
  int lastModified() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_lastModified, jni.JniCallType.longType, []).long;
  }

  static final _id_length =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"length", r"()J");

  /// from: public long length()
  int length() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_length, jni.JniCallType.longType, []).long;
  }

  static final _id_createNewFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createNewFile", r"()Z");

  /// from: public boolean createNewFile()
  bool createNewFile() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_createNewFile, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_delete =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"delete", r"()Z");

  /// from: public boolean delete()
  bool delete() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_delete, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_deleteOnExit = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"deleteOnExit", r"()V");

  /// from: public void deleteOnExit()
  void deleteOnExit() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_deleteOnExit, jni.JniCallType.voidType, []).check();
  }

  static final _id_list = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"list", r"()[Ljava/lang/String;");

  /// from: public java.lang.String[] list()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> list() {
    return const jni.JArrayType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_list, jni.JniCallType.objectType, []).object);
  }

  static final _id_list1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"list", r"(Ljava/io/FilenameFilter;)[Ljava/lang/String;");

  /// from: public java.lang.String[] list(java.io.FilenameFilter filenameFilter)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> list1(
    jni.JObject filenameFilter,
  ) {
    return const jni.JArrayType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list1, jni.JniCallType.objectType,
            [filenameFilter.reference]).object);
  }

  static final _id_listFiles = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"listFiles", r"()[Ljava/io/File;");

  /// from: public java.io.File[] listFiles()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<File> listFiles() {
    return const jni.JArrayType($FileType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_listFiles, jni.JniCallType.objectType, []).object);
  }

  static final _id_listFiles1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"listFiles",
      r"(Ljava/io/FilenameFilter;)[Ljava/io/File;");

  /// from: public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<File> listFiles1(
    jni.JObject filenameFilter,
  ) {
    return const jni.JArrayType($FileType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listFiles1,
            jni.JniCallType.objectType, [filenameFilter.reference]).object);
  }

  static final _id_listFiles2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listFiles", r"(Ljava/io/FileFilter;)[Ljava/io/File;");

  /// from: public java.io.File[] listFiles(java.io.FileFilter fileFilter)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<File> listFiles2(
    jni.JObject fileFilter,
  ) {
    return const jni.JArrayType($FileType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listFiles2,
            jni.JniCallType.objectType, [fileFilter.reference]).object);
  }

  static final _id_mkdir =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"mkdir", r"()Z");

  /// from: public boolean mkdir()
  bool mkdir() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_mkdir, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_mkdirs =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"mkdirs", r"()Z");

  /// from: public boolean mkdirs()
  bool mkdirs() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_mkdirs, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_renameTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"renameTo", r"(Ljava/io/File;)Z");

  /// from: public boolean renameTo(java.io.File file)
  bool renameTo(
    File file,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_renameTo,
        jni.JniCallType.booleanType, [file.reference]).boolean;
  }

  static final _id_setLastModified = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setLastModified", r"(J)Z");

  /// from: public boolean setLastModified(long j)
  bool setLastModified(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setLastModified,
        jni.JniCallType.booleanType, [j]).boolean;
  }

  static final _id_setReadOnly =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"setReadOnly", r"()Z");

  /// from: public boolean setReadOnly()
  bool setReadOnly() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_setReadOnly, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_setWritable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWritable", r"(ZZ)Z");

  /// from: public boolean setWritable(boolean z, boolean z1)
  bool setWritable(
    bool z,
    bool z1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setWritable,
        jni.JniCallType.booleanType, [z ? 1 : 0, z1 ? 1 : 0]).boolean;
  }

  static final _id_setWritable1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setWritable", r"(Z)Z");

  /// from: public boolean setWritable(boolean z)
  bool setWritable1(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setWritable1,
        jni.JniCallType.booleanType, [z ? 1 : 0]).boolean;
  }

  static final _id_setReadable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setReadable", r"(ZZ)Z");

  /// from: public boolean setReadable(boolean z, boolean z1)
  bool setReadable(
    bool z,
    bool z1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setReadable,
        jni.JniCallType.booleanType, [z ? 1 : 0, z1 ? 1 : 0]).boolean;
  }

  static final _id_setReadable1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setReadable", r"(Z)Z");

  /// from: public boolean setReadable(boolean z)
  bool setReadable1(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setReadable1,
        jni.JniCallType.booleanType, [z ? 1 : 0]).boolean;
  }

  static final _id_setExecutable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setExecutable", r"(ZZ)Z");

  /// from: public boolean setExecutable(boolean z, boolean z1)
  bool setExecutable(
    bool z,
    bool z1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setExecutable,
        jni.JniCallType.booleanType, [z ? 1 : 0, z1 ? 1 : 0]).boolean;
  }

  static final _id_setExecutable1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setExecutable", r"(Z)Z");

  /// from: public boolean setExecutable(boolean z)
  bool setExecutable1(
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setExecutable1,
        jni.JniCallType.booleanType, [z ? 1 : 0]).boolean;
  }

  static final _id_canExecute =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"canExecute", r"()Z");

  /// from: public boolean canExecute()
  bool canExecute() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_canExecute, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_listRoots = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"listRoots", r"()[Ljava/io/File;");

  /// from: static public java.io.File[] listRoots()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<File> listRoots() {
    return const jni.JArrayType($FileType()).fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_listRoots,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getTotalSpace = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getTotalSpace", r"()J");

  /// from: public long getTotalSpace()
  int getTotalSpace() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTotalSpace, jni.JniCallType.longType, []).long;
  }

  static final _id_getFreeSpace = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getFreeSpace", r"()J");

  /// from: public long getFreeSpace()
  int getFreeSpace() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFreeSpace, jni.JniCallType.longType, []).long;
  }

  static final _id_getUsableSpace = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getUsableSpace", r"()J");

  /// from: public long getUsableSpace()
  int getUsableSpace() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getUsableSpace, jni.JniCallType.longType, []).long;
  }

  static final _id_createTempFile = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"createTempFile",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;");

  /// from: static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static File createTempFile(
    jni.JString string,
    jni.JString string1,
    File file,
  ) {
    return const $FileType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_createTempFile,
        jni.JniCallType.objectType,
        [string.reference, string1.reference, file.reference]).object);
  }

  static final _id_createTempFile1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"createTempFile",
      r"(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;");

  /// from: static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static File createTempFile1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $FileType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_createTempFile1,
        jni.JniCallType.objectType,
        [string.reference, string1.reference]).object);
  }

  static final _id_compareTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Ljava/io/File;)I");

  /// from: public int compareTo(java.io.File file)
  int compareTo(
    File file,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo,
        jni.JniCallType.intType, [file.reference]).integer;
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_toPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toPath", r"()Ljava/nio/file/Path;");

  /// from: public java.nio.file.Path toPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toPath() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toPath, jni.JniCallType.objectType, []).object);
  }

  static final _id_compareTo1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Ljava/lang/Object;)I");

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo1,
        jni.JniCallType.intType, [object.reference]).integer;
  }
}

class $FileType extends jni.JObjType<File> {
  const $FileType();

  @override
  String get signature => r"Ljava/io/File;";

  @override
  File fromRef(jni.JObjectPtr ref) => File.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FileType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileType) && other is $FileType;
  }
}
