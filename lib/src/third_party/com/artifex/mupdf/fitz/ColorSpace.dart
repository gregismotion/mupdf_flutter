// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: com.artifex.mupdf.fitz.ColorSpace
class ColorSpace extends jni.JObject {
  @override
  late final jni.JObjType<ColorSpace> $type = type;

  ColorSpace.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/artifex/mupdf/fitz/ColorSpace");

  /// The type which includes information such as the signature of this class.
  static const type = $ColorSpaceType();
  static final _id_DeviceGray = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"DeviceGray",
    r"Lcom/artifex/mupdf/fitz/ColorSpace;",
  );

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceGray
  /// The returned object must be released after use, by calling the [release] method.
  static ColorSpace get DeviceGray =>
      const $ColorSpaceType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_DeviceGray, jni.JniCallType.objectType)
          .object);

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceGray
  /// The returned object must be released after use, by calling the [release] method.
  static set DeviceGray(ColorSpace value) => jni.Jni.env
      .SetStaticObjectField(_class.reference, _id_DeviceGray, value.reference);

  static final _id_DeviceRGB = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"DeviceRGB",
    r"Lcom/artifex/mupdf/fitz/ColorSpace;",
  );

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceRGB
  /// The returned object must be released after use, by calling the [release] method.
  static ColorSpace get DeviceRGB =>
      const $ColorSpaceType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_DeviceRGB, jni.JniCallType.objectType)
          .object);

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceRGB
  /// The returned object must be released after use, by calling the [release] method.
  static set DeviceRGB(ColorSpace value) => jni.Jni.env
      .SetStaticObjectField(_class.reference, _id_DeviceRGB, value.reference);

  static final _id_DeviceBGR = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"DeviceBGR",
    r"Lcom/artifex/mupdf/fitz/ColorSpace;",
  );

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceBGR
  /// The returned object must be released after use, by calling the [release] method.
  static ColorSpace get DeviceBGR =>
      const $ColorSpaceType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_DeviceBGR, jni.JniCallType.objectType)
          .object);

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceBGR
  /// The returned object must be released after use, by calling the [release] method.
  static set DeviceBGR(ColorSpace value) => jni.Jni.env
      .SetStaticObjectField(_class.reference, _id_DeviceBGR, value.reference);

  static final _id_DeviceCMYK = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"DeviceCMYK",
    r"Lcom/artifex/mupdf/fitz/ColorSpace;",
  );

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceCMYK
  /// The returned object must be released after use, by calling the [release] method.
  static ColorSpace get DeviceCMYK =>
      const $ColorSpaceType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_DeviceCMYK, jni.JniCallType.objectType)
          .object);

  /// from: static public com.artifex.mupdf.fitz.ColorSpace DeviceCMYK
  /// The returned object must be released after use, by calling the [release] method.
  static set DeviceCMYK(ColorSpace value) => jni.Jni.env
      .SetStaticObjectField(_class.reference, _id_DeviceCMYK, value.reference);

  static final _id_finalize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"finalize", r"()V");

  /// from: protected native void finalize()
  void finalize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_finalize, jni.JniCallType.voidType, []).check();
  }

  static final _id_destroy =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"destroy", r"()V");

  /// from: public void destroy()
  void destroy() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_destroy, jni.JniCallType.voidType, []).check();
  }

  static final _id_fromPointer = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"fromPointer",
      r"(J)Lcom/artifex/mupdf/fitz/ColorSpace;");

  /// from: static protected com.artifex.mupdf.fitz.ColorSpace fromPointer(long j)
  /// The returned object must be released after use, by calling the [release] method.
  static ColorSpace fromPointer(
    int j,
  ) {
    return const $ColorSpaceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_fromPointer,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_getNumberOfComponents = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getNumberOfComponents", r"()I");

  /// from: public native int getNumberOfComponents()
  int getNumberOfComponents() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getNumberOfComponents, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_isGray =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isGray", r"()Z");

  /// from: public native boolean isGray()
  bool isGray() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isGray, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isRGB =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRGB", r"()Z");

  /// from: public native boolean isRGB()
  bool isRGB() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRGB, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isCMYK =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isCMYK", r"()Z");

  /// from: public native boolean isCMYK()
  bool isCMYK() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isCMYK, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isIndexed =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isIndexed", r"()Z");

  /// from: public native boolean isIndexed()
  bool isIndexed() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isIndexed, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isLab =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isLab", r"()Z");

  /// from: public native boolean isLab()
  bool isLab() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isLab, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isDeviceN =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDeviceN", r"()Z");

  /// from: public native boolean isDeviceN()
  bool isDeviceN() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDeviceN, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isSubtractive = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSubtractive", r"()Z");

  /// from: public native boolean isSubtractive()
  bool isSubtractive() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSubtractive, jni.JniCallType.booleanType, []).boolean;
  }
}

class $ColorSpaceType extends jni.JObjType<ColorSpace> {
  const $ColorSpaceType();

  @override
  String get signature => r"Lcom/artifex/mupdf/fitz/ColorSpace;";

  @override
  ColorSpace fromRef(jni.JObjectPtr ref) => ColorSpace.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ColorSpaceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ColorSpaceType) && other is $ColorSpaceType;
  }
}
