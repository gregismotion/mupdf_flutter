// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: com.artifex.mupdf.fitz.PathWalker
class PathWalker extends jni.JObject {
  @override
  late final jni.JObjType<PathWalker> $type = type;

  PathWalker.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/artifex/mupdf/fitz/PathWalker");

  /// The type which includes information such as the signature of this class.
  static const type = $PathWalkerType();
  static final _id_moveTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"moveTo", r"(FF)V");

  /// from: public abstract void moveTo(float f, float f1)
  void moveTo(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_moveTo,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_lineTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"lineTo", r"(FF)V");

  /// from: public abstract void lineTo(float f, float f1)
  void lineTo(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_lineTo,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_curveTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"curveTo", r"(FFFFFF)V");

  /// from: public abstract void curveTo(float f, float f1, float f2, float f3, float f4, float f5)
  void curveTo(
    double f,
    double f1,
    double f2,
    double f3,
    double f4,
    double f5,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_curveTo, jni.JniCallType.voidType, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3),
      jni.JValueFloat(f4),
      jni.JValueFloat(f5)
    ]).check();
  }

  static final _id_closePath =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"closePath", r"()V");

  /// from: public abstract void closePath()
  void closePath() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_closePath, jni.JniCallType.voidType, []).check();
  }

  /// Maps a specific port to the implemented methods.
  static final Map<int, Map<String, Function>> _$methods = {};

  /// Maps a specific port to the type parameters.
  static final Map<int, Map<String, jni.JObjType>> _$types = {};

  ReceivePort? _$p;

  static final Finalizer<ReceivePort> _$finalizer = Finalizer(($p) {
    _$methods.remove($p.sendPort.nativePort);
    _$types.remove($p.sendPort.nativePort);
    $p.close();
  });

  @override
  void delete() {
    _$methods.remove(_$p?.sendPort.nativePort);
    _$types.remove(_$p?.sendPort.nativePort);
    _$p?.close();
    _$finalizer.detach(this);
    super.delete();
  }

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    final $d = $i.methodDescriptor.toDartString(deleteOriginal: true);
    final $a = $i.args;
    if ($d == r"moveTo(FF)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[1]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"lineTo(FF)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[1]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"curveTo(FFFFFF)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[1]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[2]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[3]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[4]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[5]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"closePath()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    return jni.nullptr;
  }

  factory PathWalker.implement({
    required void Function(double f, double f1) moveTo,
    required void Function(double f, double f1) lineTo,
    required void Function(
            double f, double f1, double f2, double f3, double f4, double f5)
        curveTo,
    required void Function() closePath,
  }) {
    final $p = ReceivePort();
    final $x = PathWalker.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.artifex.mupdf.fitz.PathWalker",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$types[$a] = {};
    _$methods[$a] = {};
    _$methods[$a]![r"moveTo(FF)V"] = moveTo;
    _$methods[$a]![r"lineTo(FF)V"] = lineTo;
    _$methods[$a]![r"curveTo(FFFFFF)V"] = curveTo;
    _$methods[$a]![r"closePath()V"] = closePath;
    _$finalizer.attach($x, $p, detach: $x);
    $p.listen(($m) {
      final $i = $MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

class $PathWalkerType extends jni.JObjType<PathWalker> {
  const $PathWalkerType();

  @override
  String get signature => r"Lcom/artifex/mupdf/fitz/PathWalker;";

  @override
  PathWalker fromRef(jni.JObjectPtr ref) => PathWalker.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PathWalkerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PathWalkerType) && other is $PathWalkerType;
  }
}
