// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: com.artifex.mupdf.fitz.PathWalker
class PathWalker extends jni.JObject {
  @override
  late final jni.JObjType<PathWalker> $type = type;

  PathWalker.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/artifex/mupdf/fitz/PathWalker");

  /// The type which includes information such as the signature of this class.
  static const type = $PathWalkerType();
  static final _id_moveTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"moveTo", r"(FF)V");

  /// from: public abstract void moveTo(float f, float f1)
  void moveTo(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_moveTo,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_lineTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"lineTo", r"(FF)V");

  /// from: public abstract void lineTo(float f, float f1)
  void lineTo(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_lineTo,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_curveTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"curveTo", r"(FFFFFF)V");

  /// from: public abstract void curveTo(float f, float f1, float f2, float f3, float f4, float f5)
  void curveTo(
    double f,
    double f1,
    double f2,
    double f3,
    double f4,
    double f5,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_curveTo, jni.JniCallType.voidType, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3),
      jni.JValueFloat(f4),
      jni.JValueFloat(f5)
    ]).check();
  }

  static final _id_closePath =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"closePath", r"()V");

  /// from: public abstract void closePath()
  void closePath() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_closePath, jni.JniCallType.voidType, []).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $PathWalkerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"moveTo(FF)V") {
        _$impls[$p]!.moveTo(
          $a[0]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"lineTo(FF)V") {
        _$impls[$p]!.lineTo(
          $a[0]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"curveTo(FFFFFF)V") {
        _$impls[$p]!.curveTo(
          $a[0]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[4]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"closePath()V") {
        _$impls[$p]!.closePath();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory PathWalker.implement(
    $PathWalkerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = PathWalker.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.artifex.mupdf.fitz.PathWalker",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $PathWalkerImpl {
  factory $PathWalkerImpl({
    required void Function(double f, double f1) moveTo,
    required void Function(double f, double f1) lineTo,
    required void Function(
            double f, double f1, double f2, double f3, double f4, double f5)
        curveTo,
    required void Function() closePath,
  }) = _$PathWalkerImpl;

  void moveTo(double f, double f1);
  void lineTo(double f, double f1);
  void curveTo(double f, double f1, double f2, double f3, double f4, double f5);
  void closePath();
}

class _$PathWalkerImpl implements $PathWalkerImpl {
  _$PathWalkerImpl({
    required void Function(double f, double f1) moveTo,
    required void Function(double f, double f1) lineTo,
    required void Function(
            double f, double f1, double f2, double f3, double f4, double f5)
        curveTo,
    required void Function() closePath,
  })  : _moveTo = moveTo,
        _lineTo = lineTo,
        _curveTo = curveTo,
        _closePath = closePath;

  final void Function(double f, double f1) _moveTo;
  final void Function(double f, double f1) _lineTo;
  final void Function(
      double f, double f1, double f2, double f3, double f4, double f5) _curveTo;
  final void Function() _closePath;

  void moveTo(double f, double f1) {
    return _moveTo(f, f1);
  }

  void lineTo(double f, double f1) {
    return _lineTo(f, f1);
  }

  void curveTo(
      double f, double f1, double f2, double f3, double f4, double f5) {
    return _curveTo(f, f1, f2, f3, f4, f5);
  }

  void closePath() {
    return _closePath();
  }
}

class $PathWalkerType extends jni.JObjType<PathWalker> {
  const $PathWalkerType();

  @override
  String get signature => r"Lcom/artifex/mupdf/fitz/PathWalker;";

  @override
  PathWalker fromRef(jni.JObjectPtr ref) => PathWalker.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PathWalkerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PathWalkerType) && other is $PathWalkerType;
  }
}
