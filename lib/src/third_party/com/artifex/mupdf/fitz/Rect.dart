// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Quad.dart" as quad_;

import "RectI.dart" as recti_;

import "StrokeState.dart" as strokestate_;

import "Matrix.dart" as matrix_;

import "Point.dart" as point_;

/// from: com.artifex.mupdf.fitz.Rect
class Rect extends jni.JObject {
  @override
  late final jni.JObjType<Rect> $type = type;

  Rect.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"com/artifex/mupdf/fitz/Rect");

  /// The type which includes information such as the signature of this class.
  static const type = $RectType();
  static final _id_x0 = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"x0",
    r"F",
  );

  /// from: public float x0
  double get x0 => jni.Jni.accessors
      .getField(reference, _id_x0, jni.JniCallType.floatType)
      .float;

  /// from: public float x0
  set x0(double value) => jni.Jni.env.SetFloatField(reference, _id_x0, value);

  static final _id_y0 = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"y0",
    r"F",
  );

  /// from: public float y0
  double get y0 => jni.Jni.accessors
      .getField(reference, _id_y0, jni.JniCallType.floatType)
      .float;

  /// from: public float y0
  set y0(double value) => jni.Jni.env.SetFloatField(reference, _id_y0, value);

  static final _id_x1 = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"x1",
    r"F",
  );

  /// from: public float x1
  double get x1 => jni.Jni.accessors
      .getField(reference, _id_x1, jni.JniCallType.floatType)
      .float;

  /// from: public float x1
  set x1(double value) => jni.Jni.env.SetFloatField(reference, _id_x1, value);

  static final _id_y1 = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"y1",
    r"F",
  );

  /// from: public float y1
  double get y1 => jni.Jni.accessors
      .getField(reference, _id_y1, jni.JniCallType.floatType)
      .float;

  /// from: public float y1
  set y1(double value) => jni.Jni.env.SetFloatField(reference, _id_y1, value);

  static final _id_ctor =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Rect() {
    return Rect.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_ctor, []).object);
  }

  static final _id_ctor1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(FFFF)V");

  /// from: public void <init>(float f, float f1, float f2, float f3)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Rect.ctor1(
    double f,
    double f1,
    double f2,
    double f3,
  ) {
    return Rect.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_ctor1, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3)
    ]).object);
  }

  static final _id_ctor2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lcom/artifex/mupdf/fitz/Quad;)V");

  /// from: public void <init>(com.artifex.mupdf.fitz.Quad quad)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Rect.ctor2(
    quad_.Quad quad,
  ) {
    return Rect.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_ctor2, [quad.reference]).object);
  }

  static final _id_ctor3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lcom/artifex/mupdf/fitz/Rect;)V");

  /// from: public void <init>(com.artifex.mupdf.fitz.Rect rect)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Rect.ctor3(
    Rect rect,
  ) {
    return Rect.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_ctor3, [rect.reference]).object);
  }

  static final _id_ctor4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lcom/artifex/mupdf/fitz/RectI;)V");

  /// from: public void <init>(com.artifex.mupdf.fitz.RectI rectI)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Rect.ctor4(
    recti_.RectI rectI,
  ) {
    return Rect.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_ctor4, [rectI.reference]).object);
  }

  static final _id_adjustForStroke = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"adjustForStroke",
      r"(Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public native void adjustForStroke(com.artifex.mupdf.fitz.StrokeState strokeState, com.artifex.mupdf.fitz.Matrix matrix)
  void adjustForStroke(
    strokestate_.StrokeState strokeState,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_adjustForStroke,
        jni.JniCallType.voidType,
        [strokeState.reference, matrix.reference]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_isInfinite =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isInfinite", r"()Z");

  /// from: public boolean isInfinite()
  bool isInfinite() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isInfinite, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_transform = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"transform",
      r"(Lcom/artifex/mupdf/fitz/Matrix;)Lcom/artifex/mupdf/fitz/Rect;");

  /// from: public com.artifex.mupdf.fitz.Rect transform(com.artifex.mupdf.fitz.Matrix matrix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Rect transform(
    matrix_.Matrix matrix,
  ) {
    return const $RectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_transform,
        jni.JniCallType.objectType,
        [matrix.reference]).object);
  }

  static final _id_contains =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"contains", r"(FF)Z");

  /// from: public boolean contains(float f, float f1)
  bool contains(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_contains,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_contains1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contains", r"(Lcom/artifex/mupdf/fitz/Point;)Z");

  /// from: public boolean contains(com.artifex.mupdf.fitz.Point point)
  bool contains1(
    point_.Point point,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_contains1,
        jni.JniCallType.booleanType, [point.reference]).boolean;
  }

  static final _id_contains2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contains", r"(Lcom/artifex/mupdf/fitz/Rect;)Z");

  /// from: public boolean contains(com.artifex.mupdf.fitz.Rect rect)
  bool contains2(
    Rect rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_contains2,
        jni.JniCallType.booleanType, [rect.reference]).boolean;
  }

  static final _id_isEmpty =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isEmpty", r"()Z");

  /// from: public boolean isEmpty()
  bool isEmpty() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isEmpty, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isValid =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isValid", r"()Z");

  /// from: public boolean isValid()
  bool isValid() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isValid, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_union = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"union", r"(Lcom/artifex/mupdf/fitz/Rect;)V");

  /// from: public void union(com.artifex.mupdf.fitz.Rect rect)
  void union(
    Rect rect,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_union,
        jni.JniCallType.voidType, [rect.reference]).check();
  }

  static final _id_inset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"inset", r"(FF)V");

  /// from: public void inset(float f, float f1)
  void inset(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_inset,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_inset1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"inset", r"(FFFF)V");

  /// from: public void inset(float f, float f1, float f2, float f3)
  void inset1(
    double f,
    double f1,
    double f2,
    double f3,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_inset1, jni.JniCallType.voidType, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3)
    ]).check();
  }

  static final _id_offset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"offset", r"(FF)V");

  /// from: public void offset(float f, float f1)
  void offset(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_offset,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }

  static final _id_offsetTo =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"offsetTo", r"(FF)V");

  /// from: public void offsetTo(float f, float f1)
  void offsetTo(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_offsetTo,
        jni.JniCallType.voidType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).check();
  }
}

class $RectType extends jni.JObjType<Rect> {
  const $RectType();

  @override
  String get signature => r"Lcom/artifex/mupdf/fitz/Rect;";

  @override
  Rect fromRef(jni.JObjectPtr ref) => Rect.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RectType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RectType) && other is $RectType;
  }
}
